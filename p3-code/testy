#!/usr/bin/env bash
#
# A script to automate testing programs on the command line.
# author:  Chris Kauffman <profk@umd.edu>
# license: GPLv3-or-later
# RELEASE: Sun Nov 26 10:38:36 PM EST 2023 

function setup_usage () {
# Create the USAGE message and provide some documentation for
# internal options

read -r -d '' USAGE <<EOF
usage:    testy <testfile.org> [test# test# ...]
          testy --help

examples: testy test_prob1.org          # runs all tests in file
          testy test_prob1.org 3 5 7    # runs tests 3,5,7 in file
          testy test_prob1.org 5        # runs only test 5 and shows failures to stdout
          SHOW=1 testy test_prob1.org   # runs tests and prints all failures to stdout
          DEBUG=1 testy test_prob1.org  # runs printing LOTS of debug messages

Run tests for a shell program specified in an org-like file and report
the results.


----------------------------------------
--- RUNNING TESTS ---
----------------------------------------

Running a test is done from the command line and will default to
running all tests in a provided test file. Output shows each test with
a pass/fail and failures have results files indicating what went
wrong. Below is an example from the examples/ directory:

>> cd examples/
>> ../testy bash_tests.org
============================================================
== testy bash_tests.org
== Running 2 / 2 tests
1)  Output Tests         : ok
2)  Failure Demo         : FAIL -> results in file 'test-results/test-02-result.tmp'
============================================================
RESULTS: 1 / 2 tests passed

Inspecting the failure file indicated (always under freshly created
directory 'test-results/' ) shows the following output (plain text but
easier easier to read in org-mode):

----------------------------------------
>> cat test-results/test-02-result.tmp
* (TEST 2) Failure Demo : FAIL
** COMMENTS
This test will fail and produce output associated to show the
side-by-side diff that primarily reports failures.


** PROGRAM: bash -v
To run this individual test in GDB use the command:
  gdb --args bash -v
but any input to the program must be typed within the debugger

** FAILURE MESSAGES
- OUTPUT DIFFERENCES:
  Expected / Actual Output Mismatch at lines marked

** SIDE-BY-SIDE DIFF of Expected vs Actual
from file 'test-results/raw/test-02-diff.tmp'
- Expect output in: test-results/raw/test-02-expect.tmp
- Actual output in: test-results/raw/test-02-actual.tmp
- Differing lines have a character like '|' and '<' in the middle

#+BEGIN_SRC sdiff
==== EXPECT ====                        ==== ACTUAL ====                     
>> echo "Matching Line"                  >> echo "Matching Line"
Matching Line                            Matching Line
>> echo "Mismatching Line"               >> echo "Mismatching Line"
Misma______ Li__                       | Mismatching Line
>> echo "Extra line in ACTUAL"           >> echo "Extra line in ACTUAL"
                                       > Extra line in ACTUAL
>> echo "Extra line in EXPECT"           >> echo "Extra line in EXPECT"
This is the extra line                 <
Extra line in EXPECT                     Extra line in EXPECT
>> printf "Matches fine\nAnd again\n"    >> printf "Matches fine\nAnd again\n"
Matches fine                             Matches fine
And again                                And again

#+END_SRC

** LINE DIFFERENCES
from file 'test-results/raw/test-02-diff-lines.tmp'
If this section is empty, there are no line differences

EXPECT:   4) Misma______ Li__
ACTUAL:   4) Mismatching Line
ACTUAL:   6) Extra line in ACTUAL
EXPECT:   7) This is the extra line

** VALGRIND NOT USED on this test, no log available

----------------------------------------

Sections include how the program was run to generate the results, a
side-by-side diff of the Expected and Actual results, a line-by-line
difference, and a Valgrind (memory checker) report if it is used
during the test (no applicable in this case).

By default, whitespace differences are ignored when doing diff checks
but this can be adjusted with the options.

----------------------------------------
--- TEST FILE FORMAT ---
----------------------------------------

Tests are specified in org-like files. Each top-level section starts
with a * with a test title, followed by comments and test sessions of
input/output. Each test can have multiple sessions. As a session is
found it is run. If the session fails, subsequent sessions for that
test are not run.

Sample input file (sample_tests.org):
----------------------------------------
#+TITLE: Sample Tests

* Test echo
Check that the 'echo' command in bash is working.

The org-mode 'sh' param is not honored in testy; it is for easy
editing/formatting in Emacs but does not reflect what program will
actually run the and can be replaced with whatever.

#+BEGIN_SRC sh
>> echo 'hello'
hello
>> echo 'Hi there!'
Hi there!
#+END_SRC

* Test printf, will fail
Tests whether printf works.

#+BEGIN_SRC sh
>> printf "Hello world\n"
Hello world
>> printf "Multi-line\noutput is expected\nhere\n"
Multi-line
output is expected
here
>> printf "%s\n" "substitute me"
substitute me
#+END_SRC

This second session below will fail (intentionally) as the output of
the printf will not match the expected output. The results of the
failure will be in a file which is listed by testy as the tests run.
#+BEGIN_SRC sh
>> echo 'hi'
hi
>> printf 'INTENTIONAL fail\n'
INTENTIONALly fails
#+END_SRC

* Test bc
This test uses a different interpreter than the standard 'bash'. The
'bc' program interprets standard mathematical expressions. Note the
use of #+TESTY expression to change the program for this test.

#+TESTY: program="bc -iq"
#+BEGIN_SRC sh
>> 1+1
2
>> 3*5+12
27
#+END_SRC
----------------------------------------

Running the command './testy sample_tests.org' will produce output like the following:

----------------------------------------
> ./testy sample_tests.org 
============================================================
== sample_tests.org : Sample Tests
== Running 3 / 3 tests
1)  Test echo              : ok
2)  Test printf, will fail : FAIL -> results in file 'test-results/test-02-result.tmp'
3)  Test bc                : ok
============================================================
RESULTS: 2 / 3 tests passed
----------------------------------------

The file listed will will contain information on the failure.



----------------------------------------
--- BEHAVIOR / ENVIRONMENT VARIABLES ---
----------------------------------------

The following variables can be specified in test files via lines like
  #+TESTY: var="value"
or via an environment variable during a program run as in
  > VAR="value" testy testfile.org
or via exporting an environment variable as in
  > export VAR="value"
  > testy testfile.org

They will change the behavior of how the test data is interpreted.

GLOBAL VARIABLES that are usually specified at the beginning of a test
file before any other tests.

PROGRAM="bash -v"         : program to run/test; input is fed to this program
PROMPT=">>"               : prompt that indicates input to the program
ECHOING="input"           : {input, both} for program input echoing style,
                            "input" means the program echoes only input provided by testy, testy will add back in prompts
                            "both" echoes both prompt and input so testy won't add back anything
                             NOTE: testy does not support mocked interaction tests for programs that don't echo input
                             as this is generally hard to do
PREFIX="test"             : prefix for test output files, often changed to reflect program name like 'myprog'
RESULTDIR="test-results"  : directory where the results will be written
RESULTRAW="RESULTDIR/raw" : directory where actual / expect / valgrind results are stored
TIMEOUT="5s"              : maximum time to complete test before it is failed due to timeout; passed to the 'timeout' utility
POST_FILTER=""            : program to adjust output from test before evaluating, run as 'cat output | post_filter > actual.tmp'
USE_VALGRIND="0"          : set to 1 to run programs under Valgrind which checks for memory errors; useful for C programs especially
VALGRIND_REACHABLE="1"    : under valgrind, report errors if memory is still reachable at the end of the program
VALGRIND_OPTS=""          : pass additional options to valgrind such as '--suppressions=test_valgrind.supp' to use a suppression file
SKIPDIFF="0"              : skip diffing results, useful if checking only valgrind with actual output varying between runs

Each of the above Global variables can be set Locally during a single
test by setting their lower-case version. For example:

  * Test 5: A test of bc
  #+TESTY: program="bc -i"

will send input to the program "bc -i" and check output rather than
the default PROGRAM. The lower case options are reset during each test
run but NOT in between sessions in single test.

Finally, these variables control some global behavior of the testy.
SHOW=0            : set to 1 to print test error results after completing
DEBUG=0           : set to 1 to print LOTS of debugging messages
REPORT_FRACTION=0 : report the fraction of tests passed rather than the count


----------------------------------------
--- TESTY MULTI ---
----------------------------------------

Standard tests are for a single program running at a time. If several
programs need to run concurrently and coordinated during a test, one
can use the special program line
  #+TESTY: PROGRAM='TESTY_MULTI'
for all tests or
  #+TESTY: program='TESTY_MULTI'
for a single test.

The test itself then takes as input a series of commands which dictate
when to start programs, feed them input, sned them signals, and wait
for them to shut down.

--- TESTY_MULTI Commands are (briefly) ---
- START <key> <program> [args]
  >> START server ./banter_server gotham      # runs program 'banter_server gotham' and refers to it via key 'server'
  >> START bruce ./banter_client gotham bruce # runs program 'banter_client gotham bruce' and refers to it via key 'bruce'

- SIGNAL <key> <sigspec>
  >> SIGNAL server -15                        # sends program w/ key 'server' signal 15 (TERM)
  >> SIGNAL bruce -INT                        # sends program w/ key 'server' a keyboard interrupt signal (15)

- INPUT <key> text text text
  >> INPUT bruce Robin? Barbara?              # sends text input to program w/ key 'bruce'
  >> INPUT clark <EOF>                        # sends End of Input to program w/ key 'clark'

- WAIT <key>
  >> WAIT server                              # causes testy to wait for program w/ key 'server' to complete

- WAIT_ALL
  >> WAIT_ALL                                 # waits for all programs to complete

- OUTPUT <key> <filter>
  >> OUTPUT server cat                        # testy prints the output for program w/ key 'server' passing to through filter 'cat'
  >> OUTPUT bruce ./test_filter_client_output # ditto but passes through the specified filter program

- OUTPUT_ALL
  >> OUTPUT_ALL cat                           # testy prints output for all programs for comparison in the test results; filtered through 'cat'
  >> OUTPUT_ALL ./test_filter_client_output   # ditto but passes through the specified filter program

- CHECK_FAILURES <key> <filter>
  >> CHECK_FAILURES server cat                # for 'server', prints any failures like timeout, non-zero return, valgrind problems, etc. 
                                              # prints nothing if no failures detected

- CHECK_ALL <filter>
  >> CHECK_ALL cat                            # checks failures in all programs that are part of test passing through 'cat' as a filter

- SHELL cmd cmd cmd
  >> SHELL rm some-file.txt                   # runs a shell command in the middle of the test in this case removing a file
----------------------------------------

An example of a TESTY_MULTI testing file is in

  testy/examples/banter_tests.org

which tests a tiny chat server/client written in bash. A server is
started and several clients 'join' the server and exchange messages.

TESTY_MULTI has a few more control global variables to dictate
behaviors specific to it.

TICKTIME="0.1"            # amount of time to wait in between test commands during a TESTY_MULTI session
VALGRIND_START_TICKS="8"  # number of ticks to wait during TESTY_MULTI when starting a program under valgrind
                          # valgrind slows things down so it takes more time for programs to start up

Depending on system speed, one may wish to lengthen these parameters
through setting them globally at the top of the testy file as in:
  #+TESTY: TICKTIME=0.1
  #+TESTY: VALGRIND_START_TICKS=8


----------------------------------------
--- CAVEATS ---
----------------------------------------

testy is in ALPHA stage and actively being developed. For that reason
no guarantees are made about its reliability. Especially TESTY_MULTI
sessions have some known failings not to mention the fact that relying
on a tick time to coordinate programs is doomed to fail at some point.

All the same, enjoy!
- Chris

EOF
}

function TODO () {
# List of comments and todos that don't seem to belong anywhere else


# TODO: separate out hte DIFF options for blanks which are currently
# -bB to ignore blanks and blank lines. Add a global variable that
# allows specific control of these options.
    echo ''
}

function setup_globals () {
# Create global variables used throughout

    STDBUF="stdbuf -i 0 -o 0 -e 0"                        # disables standard IO buffering for a program
    SDIFF="diff -yt -bB"                                  # side by side diff, no tabs, ignore space changes, ignore blank lines
    DIFF="diff -bB \
           --unchanged-line-format='' \
           --old-line-format='EXPECT:%4dn) %L' \
           --new-line-format='ACTUAL:%4dn) %L'"           # diff which will show prepend EXPECT/ACTUAL to differing lines
    TIMEOUTCMD="timeout --signal KILL"                    # kills user programs after a certain duration  of 'timeout'
    VALG_ERROR="13"                                       # error code that valgrind should return on detecting errors

    VALGRIND_PROG="valgrind"
    VALGRIND_PROG+=" --error-exitcode=13"
    VALGRIND_PROG+=" --leak-check=full"
    VALGRIND_PROG+=" --show-leak-kinds=all"
    VALGRIND_PROG+=" --track-origins=yes"
    # VALGRIND_PROG+=" --child-silent-after-fork=yes"
    # VALGRIND_PROG+=" --trace-children=no"
    # VALGRIND_PROG+=" --keep-debuginfo=yes"  # old valgrind on gradescope does not support this option

    # Uses gsed if available for BSD-based operating systems and sed
    # otherwise
    # 
    # TODO: it would be better to honor this as an environment variable
    # that defaults to "normal" sed. That way systems with a different sed
    # could set the env variable to tailor the sed cmd. Do this in a
    # future release.
    if command -v gsed >/dev/null 2>&1; then
        SEDCMD=$(command -v gsed)
    else
        SEDCMD=$(command -v sed)
    fi

    TMPFIFOS=""                                           # blank if local directory supports FIFOs, '/tmp' if FIFOS supported there instead

    # default values for the program to be tested
    PROGRAM=${PROGRAM:-"bash -v"}                         # program to run if no option is specified
    PROMPT=${PROMPT:-">>"}                                # prompt to honor if none is specified
    ECHOING=${ECHOING:-"input"}                           # {input, both} for program input echoing style
    PREFIX=${PREFIX:-"test"}                              # prefix for the files that are produced by testy
    RESULTDIR=${RESULTDIR:-"test-results"}                # directory where the results will be written
    RESULTRAW=${RESULTRAW:-"$RESULTDIR/raw"}              # directory where actual / expect / valgrind results are stored
    TIMEOUT=${TIMEOUT:-"5s"}                              # time after which to kill a test, passed to 'timeout' command and program_wait();
    DIFF_PAD_WIDTH=${DIFF_PAD_WIDTH:-"10"}                # padding space to add in side-by-side diff to prevent characters from being chopped
    POST_FILTER=${POST_FILTER:-""}                        # run this program on output to adjust it if needed
    USE_VALGRIND=${USE_VALGRIND:-"0"}                     # use valgrind while testing
    VALGRIND_REACHABLE=${VALGRIND_REACHABLE:-"1"}         # report valgrind errors if memory is still reachable
    SKIPDIFF=${SKIPDIFF:-"0"}                             # skip diffing results, useful if checking valgrind but actual output can vary
    CHECKRETURN=${CHECKRETURN:-"0"}                       # program exiting with a nonzero value triggers a failure
    VALGRIND_OPTS=${VALGRIND_OPTS:-""}                    # additional options to valgrind,
    TICKTIME=${TICKTIME:-"0.1"}                           # multi: amount of time to wait in between test commands
    VALGRIND_START_TICKS=${VALGRIND_START_TICKS:-"8"}     # multi: number of ticks to wait when starting valgrind programs which take a while
    # VALGRIND_OPTS="--suppressions=test_valg_suppress_leak.conf"
    # LONGTICKS=${LONGTICKS:-"8"}                           # number of ticks to wait starting a program w/ valgrind during TESTY_MULTI

    # INPUT_STYLE="normal"

    RETCODE_TIMEOUT=137                                   # code usually returned by timeout when it kills programs
    RETCODE_SEGFAULT=139                                  # code usually returned when OS kills a program
    PASS_STATUS="ok"                                      # status message associated with passing
    FAIL_STATUS="FAIL"                                    # default status message associated with failing a test, anything not $PASS_STATUS is a failure though
    TEST_TITLE_WIDTH=20                                   # initial width for test test_titles, set to widest during initial parsing

    USE_POINTS=0                                          # report points earned rather than tests passed
    POINTS=1                                              # default points per test
    POINTS_POSSIBLE=0                                     # total points possible, when running tests
    POINTS_LOST=0                                         # total points lost in failures

    # regular expression used to detect commands that contain shell symbols which are barred
    SHELL_SYMBOLS='.*(>|<|\||&|&&|\|\|).*' 
}

function reset_options() {
# Reset options to defaults, run before each test session. 

    program=$PROGRAM
    prompt=$PROMPT
    echoing=$ECHOING
    prefix=$PREFIX
    resultdir=$RESULTDIR
    resultraw=$RESULTRAW
    timeout=$TIMEOUT
    diff_pad_width=$DIFF_PAD_WIDTH
    post_filter=$POST_FILTER
    use_valgrind=$USE_VALGRIND
    valgrind_reachable=$VALGRIND_REACHABLE
    skipdiff=$SKIPDIFF
    checkreturn=$CHECKRETURN
    valgrind_opts=$VALGRIND_OPTS
    ticktime=$TICKTIME
    valgrind_start_ticks=$VALGRIND_START_TICKS
    points=$POINTS

    # input_style=$NORMAL
    # longticks=$LONGTICKS
}

function bash_options_for_test() {
# Sets options for this test locally to use bash. Fills the use case
# of needing to switch temporarily to using the shell for some form of
# testing.
    program="bash -v"
    prompt=">>"
    echoing="input"
    post_filter=""
    use_valgrind="0"
}

function checkdep_fail() {
# fail if a tool is not found, used to check for utilities like
# timeout and valgrind

    dep="$1"
    if ! command -v "$dep" >&/dev/null; then
        echo "ERROR: testy requires the program '$dep', which does not appear to be installed"
        echo "Consult your OS docs and install '$dep' before proceeding"
        echo "If '$dep' is installed, adjust your PATH variable so '$dep' can be found using 'which $dep'"
        which "$dep"                                  # Intentionally using 'which' as it shows the program name
        exit 1                                        # and path on stderr to help diagnose missing programs
    fi
}

function signal_exit (){
# function to run on exit signals

    printf '\ntesty was signaled: Exiting\n' > /dev/stderr
    exit 1
}

function debug() {
# print a testy debug message which is shown when running with DEBUG=1
# or TESTY_DEBUG=1. There are TONS of debug messages used and should
# likely upgrade this to debug levels at some point but the verbose
# output is extremely helpful when testy breaks.

    if [[ -n "$DEBUG" || -n "$TESTY_DEBUG" ]]; then
        echo "==DBG== $1" >/dev/stderr
    fi
}

function updateline() {
# called in after reading lins of input during input loops via
# 
#  while read .. < input
# 
# paradigm in bash. Likely will be refactoring that pattern out but
# for now this provides some basic parsing like peeling off the first
# word/token which is often special.
    line="$REPLY"                                     # copy from REPLY built-in variable to avoid losing whitespace
    ((linenum++))                                     # update the current line number
    first="${line%% *}"                               # extracts the first word on the line
    reststart=$((${#first}+1))                        # start index of rest of line
    rest="${line:$reststart}"                         # extracts remainder of line via length of first as start index
}

function tick() {
# tick the clock, used in try to coordinate multiple programs during
# multi-program testing. Increasing TICKTIME leads to longer testing
# time but more stable reuslts.
    sleep "$ticktime"
}

function program_wait() {
# Calls wait on program with given key, captures return value of
# program from wait, marks it as no longer running. If program is
# unresponsive for TIMEOUT seconds, kills it and marks it as timed
# out.
    debug "program_wait '$1'"
    key="$1"

    # Close any open FIFOs to the program before waiting on it
    if [[ "${program_input__fifo_fd[$key]}" != "CLOSED" ]]; then
        to="${program_input__fifo_fd[$key]}"          # input_fifo still open in testy, close
        debug "closing $to"
        exec {to}>&-                                  # close the input_fifo, may already have been done
        rm -f "${program_input__fifo[$key]}"          # remove input_fifo from disk
        program_input__fifo_fd[$key]="CLOSED"         # mark as closed
    else
        debug "file descriptor $fd already closed"
    fi

    debug "Waiting on pid ${program_pid[$key]}"

    wait "${program_pid[$key]}" &>/dev/null           # wait on the child to finish, safe as its done
    retcode=$?
    debug "wait on '$key' pid ${program_pid[$key]} gave retcode: $retcode"
    program_retcode[$key]=$retcode
    program_state[$key]="Done"                        # state will be changed when checking for failures

    case "$retcode" in                                # inspect return and print appropriate inline messages
        0)                                            # no action for normal return code
            ;;
        "$RETCODE_TIMEOUT")
            program_state[$key]="Timeout"
            printf "Return Code %s: TIMEOUT, program killed, not complete within %s sec limit\n" "$retcode" "$timeout"
            ;;
        "$RETCODE_SEGFAULT")
            program_state[$key]="SegFault"
            printf "Return Code %s: SIGSEGV (segmentation fault) from OS\n" "$retcode"
            ;;
        "$VALG_ERROR")
            program_state[$key]="ValgErr"
            printf "Return Code %s: Valgrind Detected Errors\n" "$retcode"
            ;;
        *)
            printf "Non-zero return code %s\n" "$retcode"
            ;;
    esac

    return 0
}

function program_alive() {
# Check if the program is running or dead. Update the program_state[]
# array for the given key setting the entry to 0 if the program is no
# longer alive.  Uses the 'kill -0 pid' trick which doesn't actually
# deliver a signal but gives a 0 return code if a signal could be
# delivered and a 1 error code if not. A return value from this of 0
# indicates success (program is still alive) and nonzero indicates the
# program is dead. Use in conditional constructs like:
#
# if ! program_alive "server"; then
#   printf "It's dead, Jim"
# fi

    key="$1"
    if [[ "${program_state[$key]}" != "Running" ]]; then
        printf "Program '$key' has already died\n"
        return 1
    fi
    pid=${program_pid[$key]}
    output=$(kill -0 "$pid" 2>&1)
    ret=$?                                            # capture return val for kill: 0 for alive, 1 for dead
    if [[ "$ret" != "0" ]]; then
        printf "Program '%s' has recently died:\n%s\n" "$key" "$output"
        program_wait "$key"                           # wait on program and mark as dead
    fi
    return $ret
}



function program_start() {
# Start a program and populate various arrays with the programs
# information such as PID, output / input sources. Checks that the
# program is actually alive after starting it and prints an error
# message if not.  Calls tick() before returning.  If Valgrind is
# used, then starts the program under Valgrind and waits a longer time
# (VALGRIND_START_TICKS) before checking on it as Valgrind usually
# takes much longer to start up programs.

# TODO: add checking for if the program fails immediately to exec;
# e.g. not found, not compiled; adjust an error message for this;
# found this is not detected in some cases and makes debugging
# difficult. This is tricky as first pass at it is near the end below
# but has some race conditions associated.

    debug "program_start '$1' '$2'"
    key="$1"
    progcmd="$2"

    if [[ "$progcmd" =~ $SHELL_SYMBOLS ]]; then
        {
            printf "ERROR with '%s'\n" "$progcmd"
            printf "TESTY_MULTI does not support program commands with shell redirects, pipes, booleans, or backgrounds\n"
            printf "The following symbols in program commands will trigger this error: > < | & || && \n"
            printf "Please rework the test file to avoid this\n"
        } >/dev/stderr
        exit 1
    fi

    program_keys+=("$key")
    debug "Adding program w/ key '$key' command '$progcmd'"
    program_command[$key]="$progcmd"
    program_name[$key]="${progcmd%% *}"
    program_output_file[$key]=$(printf "%s/%s-%02d-%s_output_file.tmp" "$resultraw" "$prefix" "$testnum" "$key")
    program_input__fifo[$key]=$(printf "%s/%s-%02d-%s_input__fifo.tmp" "$resultraw" "$prefix" "$testnum" "$key")
    if [[ -n "$TMPFIFOS" ]]; then                       # use /tmp instead, likely due to Windows/WSL
        program_input__fifo[$key]=$(printf "%s/%s-%02d-%s_input__fifo.tmp" "${TMPFIFOS}" "$prefix" "$testnum" "$key")
    fi

    rm -f "${program_input__fifo[$key]}" "${program_output_file[$key]}" # remove just in case
    mkfifo "${program_input__fifo[$key]}"                               # create the fifo going to the program

    if [[ "$use_valgrind" == 1 ]]; then                                 # setup valgrind file if needed
        program_valgfile[$key]=$(printf "%s/%s-%02d-%s_valgrd.tmp" "$resultraw" "$prefix" "$testnum" "$key")
        rm -f "program_valgfile[$key]"
        VALGRIND="${VALGRIND_PROG} ${VALGRIND_OPTS} --log-file=${program_valgfile[$key]}"
    else
        program_valgfile[$key]="NONE"
        VALGRIND=""
    fi

    # Below block starts a subshell to close extraneous file
    # descriptors then exec's the actual program. MUST close the other
    # program file descriptors otherwise when testy closes an input
    # fifo via <EOF>, other children will still have it open via FD
    # inheritance; do this in a subshell so as not to mess with testy
    # then exec to replace the process image with the child process.
    cmd="$TIMEOUTCMD $timeout $STDBUF $VALGRIND $progcmd <${program_input__fifo[$key]} &> ${program_output_file[$key]}"
    debug "running: '$cmd'"
    (
        for sig in ${suppress_signals[@]} ${exit_signals[@]}; do
            trap - $sig                                # reset trap/signal handling
        done                                           # in child procresses to default

        for tofd in "${program_input__fifo_fd[@]}"; do # close fds for input to other programs so only
            if [[ "$tofd" != "CLOSED" ]]; then         # testy owns the input
                exec {tofd}>&-
            fi
        done
        eval exec $cmd                                 # exec replaces current image with child process in a 
    ) &                                                # subshell, started in background, no quoting to all redirect
    program_pid[$key]=$!
    debug "PID is '${program_pid[$key]}'"
    program_state[$key]="Running"
    program_retcode[$key]="?"

    exec {to}>"${program_input__fifo[$key]}"            # open connection to fifo for writing
    program_input__fifo_fd[$key]=$to
    debug "to: $to   program_input__fifo_fd: ${program_input__fifo_fd[$key]}"

    if [[ "$use_valgrind" == "1" ]]; then
        debug "use_valgrind=1, long ticks while starting program"
        for i in $(seq "${valgrind_start_ticks}"); do
            tick
        done
    else
        tick
    fi

    # NOTE: Below code checks for the subprocess starting up BUT this
    # is a race condition as if the program finishes before the check,
    # then it will spuriously report that the code did not start.
    # 
    # if ! program_alive "$prog_key"; then
    #     printf "Failed to start program: %s\n" "${program_command[$key]}"
    #     return 1
    # fi
}    

function program_send_input() {
# Sends an input line to a program on standard input using the
# pre-established FIFO for that program.  The special message '<EOF>'
# will close the FIFO used for input which should give the program end
# of input. Checks that the program is alive before sending and if not
# prints and error message.  Calls tick() before returning.
    key="$1"
    msg="$2"
    debug "program_send_input '$key' '$msg'"

    if ! program_alive "$key"; then                     # check for dead program
        printf "Can't send INPUT to dead program '%s' (%s)\n" "$key" "${program_command[$key]}"
        return 1
    fi

    tofd=${program_input__fifo_fd[$key]}                # extract the file descriptor for sending data to the child program

    if [[ "$tofd" == "CLOSED" ]]; then                  # check for already closed input
        printf "Input for '%s' already closed\n" "$key" # this shouldn't be requried due to the
        return 1                                        # liveness check but is a good safety
    fi

    case "$msg" in
        "<EOF>")                                        # end of input
            debug "EOF: closing fd $tofd"
            exec {tofd}>&-                              # close fifo to child program
            program_input__fifo_fd[$key]="CLOSED"
            ;;
        *)
            printf "%s\n" "$msg" >&$tofd                # print to open file descriptor
            ;;
    esac
    tick
}

function program_signal() {
# Send a program a signal. Checks that the program is still alive
# before sending the signal. Calls tick() before returning.
# 
# NOTE: looked like there were bugs due to incorrect parameter names
# so altered this function.

    debug "program_signal '$1' '$2'"
    key="$1"
    sig="$2"
    if ! program_alive "$key"; then
        printf "Can't send SIGNAL to dead program '%s' (%s)\n" "$prog_key" "${program_command[$prog_key]}"
        return 1
    fi

    cmd="kill $sig ${program_pid[$key]}"
    eval "$cmd"
    tick
}

function program_get_output() {
# Show the output for program with given key. Makes use of the output
# file found in the program_output_file[] array. Second argument is a
# filter to use, most often 'cat' to just show the output though other
# commands/scripts can be passed to adjust the output as desired.

    debug "program_get_output '$1' '$2'"
    key="$1"
    filter="$2"
    outfile=${program_output_file[$key]}
    debug "output for '$key' is file '$outfile' with filter '$filter'"
    $filter "$outfile"                                # output the program by passing through given filter, usually 'cat'
    return $?
}


function program_check_failures() {
# Check the return code and various errors lik valgrind problems,
# timeouts, segfaults. Add any that appear to list of failures. Second
# argument is a filter to use when displaying the valgrind output,
# most often 'cat' to just show the output though other
# commands/scripts can be passed to adjust the output as desired.
# This function is affected by several options that dictate Valgrind
# applications most notably 'use_valgrind'.

# TODO: checks several output codes which do not have to do with
# valgrind, may want to convert this to 'program_failure_checks'
# instead.

# TODO: need to make compatible with the failures for the overall test
# though could rely on the output.

    debug "program_check_failures '$1' '$2'"
    # if [[ "$use_valgrind" == "0" ]]; then             # check for use of valgrind first
    #     printf "Valgrind Disabled\n"
    #     return 0;
    # fi

    key="$1"
    filter="$2"
    progcmd="${program_command[$key]}"

    retcode="${program_retcode[$key]}"
    case "$retcode" in                                # inspect return code for errors
        "$VALG_ERROR")
            test_status="$FAIL_STATUS"
            msg=""
            msg+="- VALGRIND ERRORS for ${key}"
            msg+="  '$progcmd' had Memory Errors detected by Valgrind\n"
            failmsg_brief+=("$msg")
            msg=""
            msg+="Valgrind Errors for ${key}"
            msg+="'$progcmd' had Memory Errors detected by Valgrind\n"
            msg+="Valgrind output from '${program_valgfile[$key]}'\n"
            msg+="#+BEGIN_SRC text\n"                  # org mode source block for vlagrind output
            msg+="$(cat ${program_valgfile[$key]})"
            msg+="#+END_SRC\n"
            failmsg_long+=("$msg")
            ;;
        "$RETCODE_TIMEOUT")
            test_status="$FAIL_STATUS"
            msg=""
            msg+="- TIMEOUT for ${key}:\n"
            msg+="  Program '$progcmd' still running after $timeout\n"
            failmsg_brief+=("$msg")
            msg=""
            msg+="Timeout for ${key}:\n"
            msg+="Program '$progcmd' still running after $timeout\n"
            failmsg_long+=("$msg")
            ;;
        "$RETCODE_SEGFAULT")
            test_status="$FAIL_STATUS"
            msg=""
            msg+="- SEGMENTATION FAULT for ${key} (retcode $retcode == SIGSEGV):\n"
            msg+="  Program '$progcmd' signalled with segmentation fault by OS\n"
            msg+="  Likely a memory error occurred. Try running under valgrind to see more info via\n"
            msg+="  >> valgrind $progcmd\n"
            failmsg_brief+=("$msg")
            msg=""
            msg+="Segmentation Fault for ${key}\n"
            msg+="Program '$progcmd' signalled for a segmentation fault by OS\n"
            msg+="This often appears as a non-zero return code of $retcode == SIGSEGV\n"
            msg+="Likely a memory error occurred. Try running under valgrind to see more info via\n"
            msg+="  >> valgrind $progcmd\n"
            msg+="Check the Valgrind log as if it was in use on this test it will provide clues"
            failmsg_long+=("$msg")
            # msg+="#+BEGIN_SRC text\n"                  # org mode source block for valgrind output
            # msg+="Valgrind output from '${program_valgfile[$key]}'\n"
            # msg+=$(cat ${program_valgfile[$key]})
            # msg+="#+END_SRC\n"
            ;;
        *)
            debug "checking return value '$retcode'"
            if [[ "$checkreturn" == "1" && "$retcode" != "0" ]]; then
                test_status="$FAIL_STATUS"
                msg=""
                msg+="- NON-ZERO RETURN CODE for ${key}"
                msg+="  $progcmd exited with code '$retcode' which"
                msg+="  was not expected"
                failmsg_brief+=("$msg")
                msg=""
                msg+="Non-Zero Return Code for ${key}"
                msg+="$progcmd exited with code '$retcode' which"
                msg+="was not expected"
                failmsg_long+=("$msg")
            fi
            ;;
    esac

    # if valgrind is enabled, filter its output and check for still reachable memory
    if [[ "$use_valgrind" == "1" ]]; then 
        valgfile="${program_valgfile[$key]}"
        debug "use_valgrind: $use_valgrind, valgfile: $valgfile"
        $filter $valgfile > ${valgfile/.tmp/.filtered.tmp}      # create a filtered version of the valgrind file to 
        mv $valgfile ${valgfile/.tmp/.unfiltered.tmp}
        mv ${valgfile/.tmp/.filtered.tmp} $valgfile             # remove spurious errors and use that output instead
        debug "Checking Valgrind '$key' ($progcmd) filter '$filter' valgfile '$valgfile'"

        if [[ "$valgrind_reachable" == "1" ]] &&                # and checking for reachable memory
            ! awk '/still reachable:/{if($4 != 0){exit 1;}}' ${valgfile};
        then                                                    # valgrind log does not contain 'reachable: 0 bytes'
            debug "Reachable error found"
            test_status="$FAIL_STATUS"                               
            program_state[$key]="ReachErr"     # should likely move this to where other program states are set; 
            msg=""                             # not based on return so requires a regex check
            msg+="- ${key} REACHABLE MEMORY AT EXIT\n"
            msg+="  Valgrind reports '$progcmd' has reachable\n"
            msg+="  memory at exit (e.g. a possible memory leak);"
            msg+="  may need to add free() or fclose() somewhere\n"
            failmsg_brief+=("$msg")
            msg+="Reachable Memory at Exit for ${key}\n"
            msg+="Valgrind reports '$progcmd' has reachable\n"
            msg+="memory at exit (e.g. a possible memory leak);"
            msg+="may need to add free() or fclose() somewhere\n"
            msg+="\n"
            msg+="Valgrind output from file '${program_valgfile[$key]}'\n"
            msg+="#+BEGIN_SRC text\n"                  # org mode source block for vlagrind output
            debug "cat-ing $valgfilen"
            msg+="$(cat $valgfile)"
            debug "done cat-ing $valgfilen"
            msg+="#+END_SRC\n"
            failmsg_long+=("$msg")
        fi
        debug "End of Valgrind checks"
    fi

    return 0
}

function diff_expect_actual() {
# Diffs expect/actual files and creates output diff file which are
# passed as arguments; creates $diff_file and sets
# status/failmsg_brief if differences are present. Respects "skipdiff"
# variable: no failure on differeneces if skipdiff=1

    debug "diff_expect_actual '$1' '$2'"
    expect_file="$1"
    actual_file="$2"
    outfile_sbs="$3"
    outfile_line="$4"

    actual_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' "$actual_file")
    expect_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' "$expect_file")
    col_width=$((actual_width > expect_width ? actual_width : expect_width))
    # total_width=$((actual_width + expect_width + 5))    # width to pass to diff as -W, tighter than previous
    # total_width=$((actual_width + expect_width + 10))    # width to pass to diff as -W, tighter than previous
    # diff_pad_width=10
    total_width=$((actual_width + expect_width + diff_pad_width))    # width to pass to diff as -W, tighter than previous

    debug "actual_width $actual_width expect_width $expect_width"
    debug "col_width $col_width total_width $total_width"

    # run standard diff to check for differences
    eval "$DIFF ${expect_file} ${actual_file} >& ${outfile_line}"
    diffreturn="$?"                                   # capture return value for later tests
    debug "diffreturn: $diffreturn"
    {                                                 # create side-by-side diff file
        printf "%-${col_width}s   %-${col_width}s\n" "==== EXPECT ====" "==== ACTUAL ===="
        debug "full sdiff command: $SDIFF -W $total_width \"$expect_file\" \"$actual_file\""
        $SDIFF -W $total_width "$expect_file" "$actual_file"
    } >"$outfile_sbs"

    # The below eliminate extra spaces in diff file mostly for the
    # left EXPECT column that would make the output very wide.  This
    # is a bit risky as it may eliminate some real expected output so
    # take care if the output is very wide. This is mitigated by NOT
    # changing anything in the first $actual_width columns of the
    # output file.
    if ((actual_width - expect_width > 10)); then
        extra_space_width=$((actual_width - expect_width))
        extra_space_width=$((extra_space_width - 5))
        debug "Eliminating ${extra_space_width} spaces from diff file $outfile_sbs}"
        $SEDCMD -i -E "s/(.{$expect_width})[ ]{$extra_space_width}/\1 /" "$outfile_sbs"
    fi

    # Check fof failures based on skipdiff
    if [[ "$skipdiff" == "1" ]]; then                 # skipping diff
        debug "Skipping diff (skipdiff=$skipdiff)"
    elif [[ "$diffreturn" != "0" ]]; then             # diff causes a failure
        test_status="$FAIL_STATUS"
        msg=""
        msg+="- OUTPUT DIFFERENCES"
        msg+="  Expected / Actual Output Mismatch at lines marked\n"
        failmsg_brief+=("$msg")
        msg=""
        msg+="Output Differences for $key\n"
        msg+="Expected / Actual Output mismatches at lines marked\n"
        msg+="\n"
        msg+="*** SIDE-BY-SIDE DIFFERENCE OF EXPECT / ACTUAL\n"
        msg+="- Expect output in: $expect_file\n"
        msg+="- Actual output in: $actual_file\n"
        msg+="- Differing lines have a character like '|' and '<' in the middle\n"
        msg+="\n"
        msg+="#+BEGIN_SRC sdiff\n"
        msg+="$(cat ${diff_file})"
        msg+="\n"
        msg+="#+END_SRC\n"
        msg+="\n"
        msg+="*** LINE DIFFERENCES\n"
        msg+="From file ${diffline_file}\n"
        msg+="If this section is empty, there are no line differences\n"
        msg+="\n"
        msg+="#+BEGIN_SRC text\n"
        msg+="$(cat ${diffline_file})"
        msg+="\n#+END_SRC\n"
        msg+="\n"
        failmsg_long+=("$msg")
    fi
}

function session_catfile() {
# Handle '#+BEGIN_QUOTE somefile.txt' regions which will create a file
# with the specified name in it and place text in the region in
# file. Useful for creating small-ish input files on the fly during
# tess. This output is also echoed into the comments for the test
# results.

    debug "session_catfile: $line"
    outfilename="${line##* }"                  # extract last token from the line as file name
    debug "outfilename: $outfilename"
    comments="${comments}${line}\n"
    while read -r; do                          # read a line from the test session
        updateline
        comments="${comments}${line}\n"
        if [[ "$first" == '#+END_QUOTE' ]]; then
            break
        fi
        printf "%s\n" "$line"
    done > "$outfilename"
}

function session_setup() {
# Creates arrays and other data necessary to run a testing
# session. This data is used for both single-program and multi-program
# testing sessions.

    debug "session_setup"

    if [[ "$use_valgrind" == 1 ]]; then
        checkdep_fail "valgrind"     # only check for valgrind if the test requires it
    fi

    # set names for various files associated with the whole test;
    # individual program files/proprties are tracked in arrays created
    # below which allows multiple programs to be tracked
    result_file=$(printf "%s/%s-%02d-result.tmp" "$resultdir" "$prefix" "$testnum")
    actual_file=$(printf "%s/%s-%02d-actual.tmp" "$resultraw" "$prefix" "$testnum")
    expect_file=$(printf "%s/%s-%02d-expect.tmp" "$resultraw" "$prefix" "$testnum")
    valgrd_file=$(printf "%s/%s-%02d-valgrd.tmp" "$resultraw" "$prefix" "$testnum")
    diff_file=$(printf "%s/%s-%02d-diff.tmp"   "$resultraw" "$prefix" "$testnum")
    diffline_file=$(printf "%s/%s-%02d-diff-lines.tmp" "$resultraw" "$prefix" "$testnum")

    # may wish to alter this to honor TMPDIR for this; individual file
    # which is useful for single program tests to track input but is
    # not used for multi-program tests
    toprog_file=$(printf "%s/%s-%02d-input.tmp" "$resultraw" "$prefix" "$testnum") 

    test_status="$PASS_STATUS"       # initial status, change to 'FAIL' if things go wrong
    failmsg_brief=()                 # arrays accumulating failure messages
    failmsg_long=()                  # brief are "list" format, long are section format

    # Set up the global arrays used in multi testing to track
    # input/output/state for all programs involved in the test.
    indexed_arrays=(
        program_keys                 # each program has a unique key like 'server'
    )
    assoc_arrays=(
        program_pid                  # pids of the multiple programs used during the test
        program_state                # 1 for program still running, 0 for program complete/killed
        program_name                 # name of programs, 1st word in command, useful for pkill
        program_command              # full command for each program
        program_input__fifo          # file names for fifos for writing to the program
        program_input__fifo_fd       # fds for the fifos for writing to the clients
        program_output_file          # names of files for data coming from the files
        program_retcode              # return codes for programs
        program_valgfile             # valgrind output files for programs
    )

    for a in "${indexed_arrays[@]}"; do
        unset "$a"                   # remove any existing binding
        declare -g -a "$a"           # declare as -g global, -a indexed array
    done
    for a in "${assoc_arrays[@]}"; do
        unset "$a"                   # remove any existing binding
        declare -g -A "$a"           # declare as -g global, -A Associative array
    done

    mkdir -p "$resultdir"            # set up test results directory
    mkdir -p "$resultraw"            # set up raw directory for temporary files/raw output
    
}

function session_multi_command() {
# Handles a TESTY_MULTI command; run in a context where
# printing/echoing will not go to the screen but is instead redirected
# into a file which will the "actual" results for the test session to
# be compared to the "expected" results from the test specification
# file.

    debug "session_multi_command: '$1'"
    multi_line="$1"
    multi_cmd="${multi_line%% *}"                          # extracts the first word on the line
    multi_rest="${multi_line#* }"                          # extracts remainder of line
    prog_key="${multi_rest%% *}"                           # key to identify program, only applicable to some lines
    prog_rest="${multi_rest#* }"                           # remainder of program line, only applicable to some lines
    debug "multi_cmd: '$multi_cmd' multi_rest: '$multi_rest'"
    debug "prog_key: '$prog_key' prog_rest: '$prog_rest'"

    case "$multi_cmd" in
        "START")
            program_start "$prog_key" "$prog_rest"
            ;;
        "INPUT")
            program_send_input "$prog_key" "$prog_rest"
            ;;
        "SIGNAL")                                          # 'SIGNAL server -15' == 'kill -15 ${program_pid["server"]}'
            program_signal "$prog_key" "$prog_rest"
            ;;
        "OUTPUT")
            # cat "${program_output_file[$prog_key]}"
            program_get_output "$prog_key" "$prog_rest"
            ;;
        "OUTPUT_ALL")
            for pk in "${program_keys[@]}"; do
                printf "\n<testy> OUTPUT for %s\n" "$pk"
                program_get_output "$pk" "$prog_key"       # second arg is a filter to run output through
            done
            ;;
        "CHECK_FAILURES")
            program_check_failures "$prog_key" "$prog_rest"
            ;;
        "CHECK_ALL")
            for pk in "${program_keys[@]}"; do
                printf "<testy> CHECK_FAILURES for %s\n" "$pk"
                program_check_failures "$pk" "$prog_key"   # second arg is a filter to run all valgrind checks through
            done
            ;;
        "WAIT")
            program_wait "$prog_key"
            ;;
        "WAIT_ALL")
            for pk in "${program_keys[@]}"; do
                printf "<testy> WAIT for %s\n" "$pk"
                program_wait "$pk"
            done
            ;;
        "SHELL")                                           # run a shell command in testy, could remove files, sleep testy, etc.
            eval "$multi_rest"
            ;;
        *)
            printf "TESTY FAILURE in session_multi_command():\n" >/dev/stderr
            printf "Unknown command '%s' in line '%s'\n" "$multi_cmd" "$linenum" >/dev/stderr
            printf "Aborting testy\n" >/dev/stderr
            exit 1
            ;;
    esac
    return $?
}

function session_run_multi() {
# Used when program is TESTY_MULTI. Run a test session where several
# programs must be started and coordinated at once. The session
# comprises a set of commands on when to start programs and what input
# should be given them at what time. The function is run in a context
# where 'read' will extract lines from the test session.

    debug "session_run_multi"

    session_setup

    session_beg_line=$((linenum + 1))                 # mark start of session to allow it to be extracted

    # main input loop to read lines and handle them
    while read -r; do                                 # read a line from the test session
        updateline
        debug "$linenum: $line"
        case "$first" in
            "#+END_SRC")                              # end of test, break out
                debug "^^ end of testing session"
                break
                ;;
            "$prompt")
                debug "^^ session_multi_command"
                printf "%s\n" "$line"                 # print test line so it appears in 'actual' output
                session_multi_command "$rest"
                ;;
            "#" | "")
                debug "^^ comment"
                printf "%s\n" "$line"                 # print comment so it appears in 'actual' output
                ;;
            *)                                        # other lines are test output which should be generated by the programs
                debug "^^ expected output"
                ;;
        esac
    done >"${actual_file}"                            # redirect output of printf/echo into actual output
    session_end_line=$((linenum - 1))                 # note the line session ends on to enable #+TESTY_RERUN:

    for key in "${program_keys[@]}"; do               # clean up files and other artifacts for each program
        if [[ "${program_state[$key]}" == "Running" ]]; then
            program_wait "$key"
        fi
    done >>"${actual_file}"                           # capture failures of any unresponsive_programs

    # extract expected output from test file, filter #+TESTY_ , store result in expect_file
    $SEDCMD -n "${session_beg_line},${session_end_line}p" <"$specfile" |
        grep -v '^#+TESTY_' \
        >"${expect_file}"

    # diff expect/actual output, sets 'status'
    diff_expect_actual "$expect_file" "$actual_file" "$diff_file" "$diffline_file"

    # Calculate the Width of various table fields tight
    cmd_str="COMMAND"                                 # start with width of headings for several columns
    max_cmd_width=${#cmd_str}
    out_file="OUTPUT FILE"                            
    max_out_width=${#out_file}                         # valgrind files now in same column as output files

    for key in "${program_keys[@]}"; do
        cmd_str="${program_command[$key]}"
        cmd_width=${#cmd_str}
        if ((cmd_width > max_cmd_width)); then
            max_cmd_width=$cmd_width
        fi

        out_file="${program_output_file[$key]#${resultdir}/}"      # include raw/ path to make it easier to recognize file location
        out_width=${#out_file}
        debug "File '$outfile' with width $outwidth"
        if ((out_width > max_out_width)); then
            max_out_width=$out_width
            debug "File '$out_file' has new max width $out_width"
        fi

        out_file="${program_valgfile[$key]#${resultdir}/}"         # print output file/valg files in the same column
        out_width=${#out_file}                                     # so assign the same max width as out files
        if (( $out_width > $max_out_width )); then
            max_out_width=$out_width
        fi
    done

    cw=$max_cmd_width
    ow=$max_out_width
    vw=$max_valg_width
    {
        printf '* (TEST %d) %s : %s\n' "$testnum" "$test_title" "$test_status"
        printf '** COMMENTS\n'
        printf "%b\n" "${comments}"
        printf '** program: %s\n' "$program"
        printf "If this is a TESTY_MULTI run then multiple programs are coordinated by\n"
        printf "testy itself\n"
        printf '\n'
        # printf '%s\n' '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
        # printf '%s\n' '-----------------------------------------------------------------------------------------------'
        printf "** Summary Program Information\n"
        printf "| %-8s " "KEY"
        printf "| %-${cw}s " "COMMAND"
        printf "| %3s " "RET"
        printf "| %-10s " "STATE"
        printf "| %-${ow}s " "OUTPUT/VALGRIND FILES"
        printf "| \n"
        for key in "${program_keys[@]}"; do
            printf "| %-8s " "$key"
            printf "| %-${cw}s " "${program_command[$key]}"
            printf "| %3s "      "${program_retcode[$key]}"
            printf "| %-10s "    "${program_state[$key]}"
            printf "| %-${ow}s " "${program_output_file[$key]#${resultdir}/}" # local path for out file under raw/...
            printf "| \n"

            printf "| %-8s "     ""                    # print a blank row ending with the valgrind file
            printf "| %-${cw}s " ""
            printf "| %3s "      ""
            printf "| %-10s "    ""
            printf "| %-${ow}s " "${program_valgfile[$key]#${resultdir}/}"    # local path for valg file under raw/...
            printf "| \n"
        done
        printf "\n"

        if [[ "$test_status" == "$PASS_STATUS" ]]; then     # test passed
            printf "ALL OK\n"
        else                                                # test failed
            debug "Fail with status '$status'"
            nfails="${#failmsg_long[@]}"
            printf "%d FAILURES CAUSES FOUND\n\n" "$nfails"
            fidx=1
            for msg in "${failmsg_long[@]}"; do
                # printf '%s\n' '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
                # printf '%s\n' '-----------------------------------------------------------------------------------------------'
                printf "** (FAILURE %d) %b\n" "$fidx" "${msg}"
                # printf "%b\n" "${msg}"
                printf "\n"
                ((fidx++))
            done
            printf "\n"
            fail_files+=("${result_file}")                  # test failed, add to files to show later
            test_status="FAIL -> results in file '$result_file'" # show results file on command line
        fi
    } >"${result_file}"

    # TODO: may need to clean up files that were created during
    # testing at this point and are not needed for results

    return 0
}

function program_add_prompts_to_outfile () {
# Adds prompts to input lines that are echoed without it.  Requires
# that all_input[] array be present.
# 
# NOTE: Originally was trying to do this with sed or awk but the
# quoting becomes a huge mess: any input lines with special characters
# like $ or " need to be escaped leading to huge headaches.  The shell
# string equality = operator is actually cleaner here.  The below uses
# the shell directly. Output is redirected to an open FD to prevent
# needing constantly re-open the file for appending (could
# alternatively do this with { } construct).  This approach can be
# fooled: if an output line matches an input line, the prompt may be
# added at the wrong spot.

    debug "program_add_prompts_to_outfile"

    outfile=$1
    if [[ "$echoing" != "input" ]]; then               # program may only echo input necessitating adding prompts to output
        debug "echoing is '$echoing', not adding any prompts"
        return 0
    fi

    debug "echoing is '$echoing', modifying output to add back prompts"
    idx=0                                          # index for input line
    exec {mod}>"${outfile}.mod"
    while read -r || [[ "$REPLY" != "" ]]; do      # read from output file into default REPLY var, second condition catches last line which may not end with a newline char
        if ((idx < ${#all_input[@]})) &&           # still in bounds for input lines
               [[ "${all_input[idx]}" == "$REPLY" ]]; # input line matches the program output
        then
            REPLY="$prompt $REPLY"                 # add the prompt to this line
            ((idx++))                              # move to the next input to look for
            debug "added prompt to input $idx: $REPLY"
        fi
        printf '%s\n' "$REPLY" >&$mod              # output the (un)modified line into the modified file
    done <"${outfile}"                             # reading from the original output file
    exec {mod}>&-                                  # close the modified file
    mv "${outfile}" "${outfile}.noprompt"          # save original
    mv "${outfile}.mod" "${outfile}"               # copy modified file back to original

}

function program_apply_post_filter () {
# apply the optional post_filter to an output file passed as the first arg

    outfile=$1
    if [[ "$post_filter" != "" ]]; then              # use a filter to post-process the output
        debug "running '$post_filter' on '$outfile'" # use of 'eval' for "grep -v "stuff here"' filters w/ spaces in command
        cat "${outfile}" | eval ${post_filter} >"${outfile}.tmp"
        mv "${outfile}.tmp" "${outfile}"
    fi
}

function program_adjust_timeout_message () {
# To avoid confusion, replace message from timeout program with
# easier to interpret Segfault Message

    outfile=$1
    $SEDCMD -i'' 's/timeout: the monitored command dumped core/Segmentation Fault/' "${outfile}"
}    

function file_of_array () {
# Create an file comprised of the lines in the argument array. Args
# are filename / array.  Calling this function requires some wonky
# syntax to pass in the entirety of the array:
#
# mystuff=("x" "y" "z")
# array_to_file "the_file.txt" "${mystuff[@]}"
#
# Used to create input and expect files

    outfile=$1
    shift
    array=("$@")

    debug "creating file '$outfile' from array"
    for a in "${array[@]}"; do
        printf "%s\n" "$a";
    done > ${outfile}
}

function session_single_gather_all () {
# gathers session lines as all_input[] and all_output[] arrays

    all_input=()                               # all input lines for program
    all_expect=()                              # all expected input/outpu for expect file
    session_beg_line=$((linenum + 1))          # eliminate later if possible
    eof_set=0

    # LOOP through tests output to determine the input to the
    # program. Input is added to a file file, modified later if needed
    # to re-add the prompt.
    while read -r; do                                 # read a line from the test session
        updateline
        debug "$linenum: $line"
        case "$first" in
            "#+END_SRC")                              # end of test, break out
                debug "^^ end of testing session"
                break
                ;;
            "#+TESTY_EOF:")                           # end of input, remaining session is output
                eof_set=1
                debug "^^ eof_set=1"
                ;;
            "$prompt")                                # test input, feed to program
                if [[ "$eof_set" == "0" ]]; then
                    all_expect+=("$line")
                    input="$rest"
                    all_input+=("$input")             # append to all_input array for later processing
                    debug "^^ found input '$input'"
                else
                    all_expect+=("$line")
                    debug "^^ prompt after EOF is output"
                fi
                ;;
            *)                                        # other lines are test output
                all_expect+=("$line")
                debug "^^ expected output"
                ;;
        esac                                          # DONE with test input, either pass or fail
    done

    session_end_line=$((linenum - 1))                 # note the line session ends on to enable #+TESTY_RERUN:
    debug "session lines: beg $session_beg_line end $session_end_line"


}

function session_single_result_file () {
# Create the results file for a test of a single program. Sole
# parameter is the output file name to be created.

    outfile=$1
    {                           
        # output the intitial header information
        printf '* (TEST %d) %s : %s\n' "$testnum" "$test_title" "$test_status"
        printf '** COMMENTS\n'
        printf "%b\n" "${comments}"

        printf '** PROGRAM: %s\n' "$program"
        printf 'To run this individual test in GDB use the command:\n'
        printf '  gdb --args %s\n' "$program"
        printf 'but any input to the program must be typed within the debugger\n'
        printf "\n"
 
        # output failure messages
        printf '** FAILURE MESSAGES\n'
        for msg in "${failmsg_brief[@]}"; do       # iterate through failure messages
            printf "%b\n" "$msg"
        done

        # output the diff files, side-by-side and line-by-line. Diffs
        # are shown irrespective of test success or failure
        printf "%s\n" "** SIDE-BY-SIDE DIFF of Expected vs Actual"
        printf "%s\n" "from file '${diff_file}'"
        printf "%s\n" "- Expect output in: $expect_file"
        printf "%s\n" "- Actual output in: $actual_file"
        printf "%s\n" "- Differing lines have a character like '|' and '<' in the middle"
        printf "\n"
        printf "%s\n" "#+BEGIN_SRC sdiff"
        cat "${diff_file}"
        printf "\n"
        printf "%s\n" "#+END_SRC"
        printf "\n"
        printf "%s\n" "** LINE DIFFERENCES"
        printf "%s\n" "from file '${diffline_file}'"
        printf "%s\n" "#+BEGIN_SRC text"
        printf "If this section is empty, there are no line differences\n\n"
        cat "${diffline_file}"
        printf "%s\n" "#+END_SRC"
        printf "\n"

        if [[ "$use_valgrind" == "1" ]]; then      # show valgrind log if enabled 
            printf "%s\n" "** VALGRIND LOG from: ${valgrd_file}"
            cat "${valgrd_file}"
            printf "\n"
        else
            printf "%s\n" "** VALGRIND NOT USED on this test, no log available"
        fi

    } > "${outfile}"
}


function session_run_single () {
# Run a Test Session for a Single Program which is between a
# #+BEGIN_SRC/#+END_SRC pair in the spec file. Runs in a context where
# 'read' will accept input from the session lines.

    debug "session_run_single ()"
    session_setup                                   # creates array, vars like expect_file

    session_single_gather_all                       # creates all_input[] and all_expect[] 
    file_of_array "$toprog_file" "${all_input[@]}"  # create input file for program
    file_of_array "$expect_file" "${all_expect[@]}" # create expected output file for program

    # RUN THE PROGRAM
    progkey="$(basename ${program%% *})"           # use first word of program as key, basename omits path to prog
    program_start "$progkey" "$program"            # creates to FIFO 


    # subprocess to dump input file to input fifo; this must run async
    # in case it blocks as otherwise testy may hang here; this should
    # feed all input to the program through the FIFO allowing it to
    # run to to completion and produce to actual output
    cat "${toprog_file}" > "${program_input__fifo[$progkey]}" 2> /dev/null &

    # to="${program_input__fifo_fd[$progkey]}"       # input_fifo still open in testy, close
    # exec {to}>&-                                   
    program_wait "$progkey" >> "${program_output_file[$progkey]}" # NOTE: this may generate output...
    
    # copy the single program output to singular files for whole test;
    # possible in single mode but in multi-mode, multiple programs each
    # have their own output / valgrind.
    debug "Copy prog output to single: cp '${program_output_file[$progkey]}' '$actual_file'"
    cp "${program_output_file[$progkey]}" "$actual_file"
    debug "Check for '${program_valgfile[$progkey]}'"
    if [[ -e "${program_valgfile[$progkey]}" ]]; then
        debug "Copy prog valgfile to single: cp '${program_valgfile[$progkey]}' '$valgrd_file'"
        cp "${program_valgfile[$progkey]}" "$valgrd_file"
    fi
    # NOTE: Intentionally copying files in the aboe rather than
    # alternatives such as sym/hard linking files (may be
    # non-portable) or simply using variable names that refer to the
    # files used (may create confusion as the naming for single tests
    # is irregular then). May revisit these decisions later.

    program_add_prompts_to_outfile "$actual_file"     # adjust program output in several ways
    program_apply_post_filter "$actual_file"
    program_adjust_timeout_message "$actual_file"

    # diff expect/actual output, sets 'status'
    diff_expect_actual "$expect_file" "$actual_file" "$diff_file" "$diffline_file"
    program_check_failures "$progkey" "cat"           # second filter arg appliees to valgrind output

    session_single_result_file "$result_file"         # produce output file

    ((POINTS_POSSIBLE+=points))
    if [[ "$test_status" != "$PASS_STATUS" ]]; then   # test failed
        fail_files+=("${result_file}")                # add results to files to show
        test_status="FAIL -> results in file '${result_file}'"
        ((failcount++))
        ((POINTS_LOST+=points))
    fi

    comments=""                                       # clear comments for next session
    # NOTE: probably move this to parsing instead
    return 0                                          # required?
}

function run_test_session() {
# DEPRECATED VERSION: replaced by session_run_single
# Run a Test Session for a Single Program
#
# Sets up a test session which is denoted by the #+BEGIN_SRC/#+END_SRC
# tags in the input file. Will set the 'status' variable before
# exiting to indicate whether the test passes or fails. Influenced by
# many of the run variables including
# - program
# - tag
# - prompt
#
# The function is run in a context where 'read' will extract lines
# from the test session.

    mkdir -p "$resultdir"                               # set up test results directory
    mkdir -p "$resultraw"
    result_file=$(printf "%s/%s-%02d-result.tmp" "$resultdir" "$prefix" "$testnum")
    actual_file=$(printf "%s/%s-%02d-actual.tmp" "$resultraw" "$prefix" "$testnum")
    expect_file=$(printf "%s/%s-%02d-expect.tmp" "$resultraw" "$prefix" "$testnum")
    valgrd_file=$(printf "%s/%s-%02d-valgrd.tmp" "$resultraw" "$prefix" "$testnum")
    rm -f "${actual_file}" "${expect_file}" "${result_file}" "${valgrd_file}"

    if [[ "$use_valgrind" == 1 ]]; then
        checkdep_fail "valgrind"                        # only check for valgrind if the test requires it
        VALGRIND="${VALGRIND_PROG} ${VALGRIND_OPTS} --log-file=${valgrd_file}"
    else
        VALGRIND=""
    fi

    toprog_file=$(printf "%s/%s-%02d-tofile.tmp" "$resultraw" "$prefix" "$testnum")       # may wish to alter this to honor TMPDIR
    fromprog_file=$(printf "%s/%s-%02d-fromfile.tmp" "$resultraw" "$prefix" "$testnum")   # input / output files for program
    debug "toprog_file: $toprog_file"
    debug "fromprog_file: $fromprog_file"
    rm -f "${toprog_file}" "${fromprog_file}"         # remove just in case


    all_input=()                                      # array accumulating input fed to program
    session_beg_line=$((linenum + 1))
    eof_set=0


    # LOOP through tests output to determine the input to the
    # program. Input is added to a file file, modified later if needed
    # to re-add the prompt.
    while read -r; do                                 # read a line from the test session
        updateline
        debug "$linenum: $line"
        case "$first" in
            "#+END_SRC")                              # end of test, break out
                debug "^^ end of testing session"
                break
                ;;
            "#+TESTY_EOF:")                           # end of input, remaining session is output
                eof_set=1
                debug "^^ eof_set=1"
                ;;
            "$prompt")                                # test input, feed to program
                if [[ "$eof_set" == "0" ]]; then
                    input="$rest"
                    all_input+=("$input")             # append to all_input array for later processing
                    debug "^^ found input '$input'"
                else
                    debug "^^ ignoring prompt after EOF"
                fi
                ;;
            *)                                        # other lines are test output
                debug "^^ expected output"
                ;;
        esac                                          # DONE with test input, either pass or fail
    done

    session_end_line=$((linenum - 1))                 # note the line session ends on to enable #+TESTY_RERUN:
    debug "session lines: beg $session_beg_line end $session_end_line"

    # CREATE PROGRAM INPUT FILE by iterating through the all_input
    # variable and ploppoing it down in a file
    debug "creating program input file '$toprog_file'"
    for a in "${all_input[@]}"; do
        printf "%s\n" "$a";
    done > ${toprog_file}


    # RUN THE PROGRAM
    #
    # - timeout will kill the program after a certain duration
    # - stdbuf disables buffering and prevents stalled output problems
    # - valgrind may be turned on to check for memory errors
    # - input is read from a file created above from the specfile
    # - output is directed to a file
    cmd="$TIMEOUTCMD $timeout $STDBUF $VALGRIND $program <${toprog_file} &> ${fromprog_file} &"
    debug "running: '$cmd'"
    eval "$cmd"                                       # eval is required due to the complex redirections with < and >
    pid=$!
    debug "child pid: $pid"

    debug "waiting on finished child"
    wait $pid &>/dev/null                             # wait on the child to finish
    retcode="$?"                                      # capture return code from program run
    debug "wait returned: $retcode"

    test_status="$PASS_STATUS"                        # initial status, change to 'FAIL' if things go wrong
    failmsg_brief=()                                  # array accumulating failure messages
    case "$retcode" in                                # inspect return code for errors
        "$VALG_ERROR")
            test_status="$FAIL_STATUS"
            failmsg_brief+=("FAILURE($retcode): Valgrind detected errors")
            ;;
        "$RETCODE_TIMEOUT")
            test_status="$FAIL_STATUS"
            failmsg_brief+=("FAILURE($retcode) due to TIMEOUT: Runtime exceeded maximum of '$timeout'")
            ;;
        "$RETCODE_SEGFAULT")
            test_status="$FAIL_STATUS"
            failmsg_brief+=("FAILURE($retcode) due to SIGSEGV (segmentation fault) from OS")
            ;;
        *)
            debug "checking return value '$retcode'"
            if [[ "$checkreturn" == "1" && "$retcode" != "0" ]]; then
                test_status="$FAIL_STATUS"
                failmsg_brief+=("FAILURE: program returned $retcode (non-zero) triggering failure")
                skipdiff=0      # hack to show diffed output on non-zero return, possibly from valgrind subprocess
            fi
    esac

    if [[ "$use_valgrind" == "1" ]] &&                # if valgrind is on
        [[ "$valgrind_reachable" == "1" ]] &&         # and checking for reachable memory
        ! awk '/still reachable:/{if($4 != 0){exit 1;}}' "${valgrd_file}";
    then                                              # valgrind log does not contain 'reachable: 0 bytes'
        test_status="$FAIL_STATUS"
        failmsg_brief+=("FAILURE: Valgrind reports reachable memory, may need to add free() or fclose()")
    fi

    # ADDING IN PROMPTS TO ECHOED INPUT
    #
    # NOTE: The code below handles adding prompts to input lines that
    # are echoed without it.  Originally was trying to do this with
    # sed or awk but the quoting becomes a huge mess: any input lines
    # with special characters like $ or " need to be escaped leading
    # to huge headaches.  The shell string equality = operator is
    # actually cleaner here.  The below uses the shell
    # directly. Output is redirected to an open FD to prevent needing
    # constantly re-open the file for appending (could alternatively
    # do this with { } construct).  This approach can be fooled: if an
    # output line matches an input line, the prompt may be added at
    # the wrong spot.
    if [[ "$echoing" == "input" ]]; then               # program may only echo input necessitating adding prompts to output
        idx=0                                          # index for input line
        exec {mod}>"${fromprog_file}.mod"
        while read -r || [[ "$REPLY" != "" ]]; do      # read from output file into default REPLY var, second condition catches last line which may not end with a newline char
            if ((idx < ${#all_input[@]})) &&           # still in bounds for input lines
                [[ "${all_input[idx]}" == "$REPLY" ]]; # input line matches the program output
            then
                REPLY="$prompt $REPLY"                 # add the prompt to this line
                ((idx++))                              # move to the next input to look for
                debug "added prompt to input $idx: $REPLY"
            fi
            printf '%s\n' "$REPLY" >&$mod              # output the (un)modified line into the modified file
        done <"${fromprog_file}"                       # reading from the original output file
        exec {mod}>&-                                  # close the modified file
        mv "${fromprog_file}.mod" "${fromprog_file}"   # copy modified file back to original
    fi

    if [[ "$post_filter" != "" ]]; then                # use a filter to post-process the output
        debug "running post filter '$post_filter'"     # use of 'eval' for "grep -v "stuff here"' filters w/ spaces in command
        cat "${fromprog_file}" | eval ${post_filter} >"${fromprog_file}.tmp"
        mv "${fromprog_file}.tmp" "${fromprog_file}"
    fi

    # To avoid confusion, replace message from timeout program with
    # easier to interpret Segfault Message
    $SEDCMD -i'' 's/timeout: the monitored command dumped core/Segmentation Fault/' "${fromprog_file}"

    mv "${fromprog_file}" "${actual_file}"                # copy temp file to final destination

    # extract expected output from test file, filter #+TESTY_ , store result in expect_file
    range="${session_beg_line},${session_end_line}p"      # range of lines for sed to print
    if ((session_beg_line > session_end_line)); then      # in sed, if start > end then the
        range=""                                          # start line still gets printed so
    fi                                                    # set range to nothing for empty output
    $SEDCMD -n "$range" <"$specfile" |
        grep -v '^#+TESTY_' \
        >"${expect_file}"

    # Try to compute the width of expected/actual outputs to make the
    # side-by-side diff as narrow as possible. 'diff -y -W' is a bit
    # funky as it tries to split the side-by-side comparison into evey
    # column widths. The below computation finds the maximum width of
    # the two compared files and doubles it adding 3 for the middle
    # diff characters. This may result in an grossly wide display if
    # the left EXPECT column is narrow while the right ACTUAL column
    # wide. Later code filters to remove extraneous whitespace from
    # the left column.
    actual_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' "$actual_file")
    expect_width=$(awk 'BEGIN{max=16}{w=length; max=w>max?w:max}END{print max}' "$expect_file")
    col_width=$((actual_width > expect_width ? actual_width : expect_width))
    total_width=$((col_width * 2 + 3))                # width to pass to diff as -W
    debug "actual_width $actual_width"
    debug "expect_width $expect_width"
    debug "col_width $col_width"
    debug "total_width $total_width"

    diffcmd="$DIFF ${expect_file} ${actual_file}"     # run standard diff to check for differences
    diffresult=$(eval "$diffcmd")
    diffreturn="$?"                                   # capture return value for later tests
    debug "diffresult: $diffresult"
    debug "diffreturn: $diffreturn"
    if [[ "$skipdiff" == "1" ]]; then                 # skipping diff
        debug "Skipping diff (skipdiff=$skipdiff)"
        diffreturn=0
    elif [[ "$diffreturn" != "0" ]]; then
        test_status="$FAIL_STATUS"
        failmsg_brief+=("FAILURE: Output Mismatch at lines marked")
    fi

    if [[ "$test_status" == "$PASS_STATUS" ]]; then        # test passed
        debug "NORMAL cleanup"                        # normal finish
        debug "Checking child status with kill -0"
        kill -0 $pid >&/dev/null                      # check that the child is dead, return value 1
        debug "kill returned: $?"
    else
        debug "FAILURE cleanup"                       # test failed for some reason
        {                                             # begin capturing output for results file
           printf '* (TEST %d) %s\n' "$testnum" "$test_title"
           printf 'COMMENTS:\n'
           printf "%b" "${comments}"
           printf '** program: %s\n' "$program"
           printf 'To run this individual test in GDB use the command:\n'
           printf '  gdb --args %s\n' "$program"
           printf 'but any input to the program must be typed within the debugger\n'
           printf "\n"
           printf '** --- Failure messages --- \n'
           for msg in "${failmsg_brief[@]}"; do       # iterate through failure messages
               printf "%s\n" "- $msg"
           done
           printf "\n"

           if [[ "$diffreturn" != "0" ]]; then        # show differences between expect and actual
               printf "%s\n" "** --- Side by Side Differences ---"
               printf "%s\n" "- Expect output in: $expect_file"
               printf "%s\n" "- Actual output in: $actual_file"
               printf "%s\n" "- Differing lines have a character like '|' '>' or '<' in the middle"
               printf "%s\n" "#+BEGIN_SRC sdiff"
               printf "%-${col_width}s   %-${col_width}s\n" "==== EXPECT ====" "==== ACTUAL ===="
               $SDIFF -W $total_width "$expect_file" "$actual_file"
               printf "%s\n" "#+END_SRC"
               printf "\n"
               printf "%s\n" "** --- Line Differences ---"
               printf "%s\n" "$diffresult"
               printf "\n"
           fi

           if [[ "$use_valgrind" == "1" ]]; then      # show valgrind log if enabled and test failed
               printf "%s\n" "--- Valgrind Log from: $valgrd_file ---"
               cat "$valgrd_file"
               printf "\n"
           fi
        } &>"${result_file}"                          # end of results file output

        # The below eliminate extra spaces in diff results mostly for
        # the left EXPECT column that would make the output very wide.
        # This is a bit risky as it may eliminate some real expected
        # output so take care if the output is very wide. This is
        # mitigated by NOT changing anything in the first
        # $actual_width columns of the output file.
        if ((actual_width - expect_width > 10)); then
            extra_space_width=$((actual_width - expect_width))
            extra_space_width=$((extra_space_width - 5))
            debug "Eliminating $extra_space_width spaces from result file"
            $SEDCMD -i -E "s/(.{$expect_width})[ ]{$extra_space_width}/\1 /" "$result_file"
        fi

        fail_files+=("${result_file}")                # test failed, add to files to show later
        test_status="FAIL -> results in file '$result_file'"
        ((failcount++))
    fi

    # if [[ "$test_status" != "$PASS_STATUS" ]]; then   # test failed
    #     fail_files+=("${result_file}")                # add results to files to show
    #     test_status="FAIL -> results in file '${result_file}'"
    #     ((failcount++))
    # fi

    comments=""                                       # clear comments for next session
    return 0
}

function main () {
# MAIN PROCESSING LOOP

    # call setup functions which establish globals
    setup_usage
    setup_globals

    unset BASH_ENV                                        # ensure subshells don't spit out extra gunk

    suppress_signals=(SIGSEGV SIGFPE SIGILL SIGBUS)       # trap these signals to suppress child processes
    for sig in ${suppress_signals[@]}; do                 # from generating bash error messages when they 
        trap "" $sig                                      # receive these signals; testy should not generate
    done                                                  # these signals but child processes might

    exit_signals=(SIGINT SIGTERM)                         # signals that will cause testy to exit
    for sig in ${exit_signals[@]}; do
        trap "signal_exit" $sig
    done


    funcs=$(declare -x -F | awk '{print $3}')             # eliminate any exported functions in bash
    for f in $funcs; do                                   # as these are output with the -v option
        unset -f "$f"
    done

    if [[ "$#" -lt 1 ]]; then                             # check for presence of at least 1 argument
        printf "usage: testy <testspec> [testnum]\n"
        printf "       testy --help\n"
        exit 1
    fi

    # Command line argument processing
    specfile=$1                                           # gather test file
    shift                                                 # shift test file off the command line
    alltests="$*"                                         # remaining args are tests to run
    debug "Testing $specfile"
    debug "alltests='$alltests"

    if [[ "$specfile" == "--help" ]]; then                # check for --help option
        printf "%s\n" "$USAGE"                            # print usage and exit
        exit 0
    fi

    if [[ ! -r "$specfile" ]]; then                       # check specfile exists / readable
        printf "ERROR: could not open '%s' for reading\n" "$specfile" >/dev/stderr
        exit 1
    fi

    deps="timeout stdbuf awk $SEDCMD grep diff"           # check for baseline necessary tools
    for dep in $deps; do
        checkdep_fail "$dep"
    done

    rm -f ./test-fifo.fifo /tmp/test-fifo.fifo              # Test FIFO creation, often fails for Windows file systems on WSL, can
    if !  mkfifo ./test-fifo.fifo &> /dev/null ; then       # FIFOs in current directory?
        debug "Can't create fifos in $PWD"
        if ! mkfifo /tmp/test-fifo.fifo &>/dev/null; then # FIFOs in /tmp?
            printf "ERROR: Can't create FIFOs in %s or /tmp; Bailing out\n" "$PWD"
            rm -f ./test-fifo.fifo /tmp/test-fifo.fifo
            exit 1
        else                                              # use FIFOS in /tmp
            TMPFIFOS="/tmp/$USER"                         # name directory after user to avoid conflicts on shared systems
            mkdir -p $TMPFIFOS
            debug "Local dir $PWD can't handle FIFOs, Creating FIFOs in $TMPFIFOS"
        fi
    fi
    rm -f ./test-fifo.fifo /tmp/test-fifo.fifo

    ##################################################
    # first processing loop: read whole file into testdata array which will
    # contain the text of each test. Record ONLY the start/end lines of
    # each test to be used later.  Other side effects: evaluate any global
    # #+TESTY: expressions, calculate the widest test title width for nice
    # display later.
    eval_testy_expr=1                                     # set to 0 after getting into the first test
    test_beg_line=(-1)
    test_end_line=(-1)
    testnum=0                                             # current test number
    linenum=0
    while read -r; do                                     # read from test file, -r to prevent \-escaped chars
        updateline
        debug "$linenum: $line\n"
        case "$first" in
            "*")
                debug "^^ Test Start"
                eval_test_expr=0                          # in a test, wait to evaluate #+TESTY: expr until during test
                if ((testnum > 0)); then                  # if not the first test
                    endline=$((linenum - 1))
                    test_end_line+=("$endline")
                    beg=${test_beg_line[testnum]}
                    end=${test_end_line[testnum]}
                    debug "Test $testnum beg $beg end $end"
                fi
                ((testnum++))                             # reset and start collecting text for the new test
                test_beg_line+=("$linenum")
                if ((${#rest} > TEST_TITLE_WIDTH));       # calculate maximum width of any title
                then
                    TEST_TITLE_WIDTH=${#rest}
                fi
                ;;
            "#+TESTY:")                                   # evaluate global expressions
                if [[ "$eval_testy_expr" == "1" ]]; then
                    debug "Evaluating '$rest'"
                    eval "$rest"
                    if [[ $? != 0 ]]; then                # check syntax error, print error message
                        printf "%s: line %d: Syntax error in test file, bailing out\n" "$specfile" "$linenum"
                        exit 1                            # this format used to be amenable to emacs compilation/jump to error
                    fi
                fi
                testtext="$testtext\n$line"               # append line to current test text as it may be a local test option
                ;;
            "#+TITLE:" | "#+title:")
                global_title="$rest"
                debug "^^ setting global_title"
                ;;
            *)
                debug "^^ Ignoring line in first pass"
                ;;
        esac
    done <"$specfile"

    endline=$((linenum))                                  # append the last test end
    test_end_line+=("$endline")
    beg=${test_beg_line[testnum]}
    end=${test_end_line[testnum]}
    debug "Test $testnum beg $beg end $end"

    totaltests=$testnum                                   # set the total number of tests read from the file

    # Debug output
    for i in $(seq "$testnum"); do
        debug "-----TEST $i: beg ${test_beg_line[i]} end: ${test_end_line[i]} -----"
        while read -r; do                                # iterate over all lines of test
            debug ":TEST $i: $REPLY"
        done <<<"$($SEDCMD -n "${test_beg_line[i]},${test_end_line[i]}p" "$specfile")"
    done

    ##################################################
    # Second loop: run tests

    if [[ -z "$alltests" ]]; then                         # no individual tests specified on the command line
        alltests=$(seq "$totaltests")                     # so run all tests
    fi
    ntests=$(wc -w <<<"$alltests")                        # count how many tests will be run

    checktests="$alltests"                                # filter out tests not in range
    alltests=""
    for t in $checktests; do
        if ((t <= totaltests)); then
            alltests+="$t "
        else
            printf "WARNING: skipping out of range test %s\n" "$t"
        fi
    done
    ntests=$(wc -w <<<"$alltests")                        # update cout of total tests

    if [[ "$ntests" == "1" && "$SHOW" == "" ]]; then
        debug "Running single test, setting SHOW=1 to display single test results"
        SHOW=1
    fi

    testcount=0
    failcount=0

    # Print header info

    printf "============================================================\n"
    if [[ "$global_title" == "" ]]; then
        printf "== testy %s\n" "$specfile"
    else
        printf "== $specfile : %s\n" "$global_title"
    fi
    printf "== Running %d / %d tests\n" "$ntests" "$totaltests"

    for testnum in $alltests; do                          # Iterate over all tests to be run
        ((testcount++))                                   # increment # of tests attempted
        reset_options
        comments=""                                       # initialize comments
        linenum=$((test_beg_line[testnum] - 1))
        debug ":TEST $testnum: START at line $linenum"

        while read -r; do                                 # iterate over all lines of test
            updateline
            debug "$linenum: $line"

            case "$first" in
                "*")                                      # usually first line with title of the test
                    test_title="$rest"
                    debug "test_title: $test_title"
                    ;;
                "#+TESTY:")                               # eval some code to set options
                    debug "evaluating '$rest'"
                    eval "$rest"
                    ;;
                "#+BEGIN_SRC")                            # test session starting
                    debug ":TEST $testnum: Begin testing session"
                    if [[ "$program" == "TESTY_MULTI" ]]; then
                        session_run_multi
                    else
                        if [[ "$OLD_SINGLE" != "" ]]; then
                            run_test_session
                        else
                            session_run_single
                        fi
                    fi
                    if [[ "$test_status" != "$PASS_STATUS" ]]; then
                        # ((failcount++))                   # test failed, bail out of this test
                        break
                    fi
                    ;;
                "#+BEGIN_QUOTE")                          # create a file with the quoted material in it
                    session_catfile
                    ;;
                "#+TESTY_RERUN:")                         # eval some code to set options
                    old_linenum=$linenum
                    beg=$((session_beg_line))             # #+BEGIN_SRC line
                    end=$((session_end_line + 1))         # #+END_SRC line
                    linenum=$((beg - 1))
                    debug "^^ Re-running session on lines $beg to $end"
                    if ((beg == 0)); then
                        {
                            printf "ERROR in test %s with directive '#+TESTY_RERUN'\n" "$testnum"
                            printf "Alas, testy does not support rerunning a test that hasn't already been run\n"
                            printf "Try running all tests instead\n"
                        } >/dev/stderr
                        exit 1
                    fi

                    if [[ "$program" == "TESTY_MULTI" ]]; then
                        session_run_multi <<<"$($SEDCMD -n "${beg},${end}p" "$specfile")"
                    else
                        run_test_session <<<"$($SEDCMD -n "${beg},${end}p" "$specfile")"
                    fi
                    debug "Done re-running session on lines $beg to $end"
                    linenum=$old_linenum

                    if [[ "$test_status" != "$PASS_STATUS" ]]; then # this block should be here, right?
                        break                                       # test failed, bail out of this test
                    fi
                    ;;
                *)                                        # any other lines are comments associated with a session
                    if [[ "$comments" != "" ]] || [[ "$line" != "" ]]; then
                        debug "^^ comment"                # ignore leading blank lines in comments
                        comments="${comments}${line}\n"
                    fi
                    ;;
            esac
        done <<<"$($SEDCMD -n "${test_beg_line[testnum]},${test_end_line[testnum]}p" "$specfile")"

        # report the final status of this test
        printf "%-3s %-${TEST_TITLE_WIDTH}s : %s\n" "${testnum})" "$test_title" "$test_status"
    done

    ########################################
    # Final Output
    passcount=$((testcount - failcount))                  # calculate number of tests passed
    if [[ "$REPORT_FRACTION" == "1" ]]; then              # reporting fraction of tests passed
        passcount=$(awk "BEGIN{printf(\"%0.2f\n\",$passcount / $testcount)}")
        testcount="1.00"
    fi
    points_earned=$((POINTS_POSSIBLE - POINTS_LOST))

    printf "============================================================\n"

    if [[ "$USE_POINTS" != "0" && "$SCALE_POINTS" != "0" ]]; then
        awk "BEGIN{ \
              printf(\"RESULTS: %.2f / %.2f point earned\n\",\
                     $points_earned*$SCALE_POINTS,\
                     $POINTS_POSSIBLE*$SCALE_POINTS)\
             }"
    elif [[ "$USE_POINTS" != "0" ]]; then
        printf "RESULTS: %s / %s point earned\n" "$points_earned" "$POINTS_POSSIBLE"
    else
        printf "RESULTS: %s / %s tests passed\n" "$passcount" "$testcount"
    fi

    debug "SHOW: $SHOW"
    if [[ "$SHOW" == "1" && "${#fail_files[@]}" -gt 0 ]]; then # show failure results if requested
        printf "\n\n"
        printf "============================================================\n"
        printf "== FAILURE RESULTS\n"
        # printf "%s\n" "----------------------------------------"
        for f in "${fail_files[@]}"; do                        # iterate over all failure files outputting them
            printf "============================================================\n"
            cat "$f"
        done
    fi
    
    # kill all descendent processes at this point; should not be
    # necessary but in some cases may clean up errant child processes
    # which have escaped
    pkill -P $$
    return 0
}

# call the main function with all command line args
main $@
